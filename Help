

    Help (version 1.0) 

Любая программа состоит из похожих элементов (будь то игры, утилиты, сервисы и т.д).
Основные элементы это циклы и условные переходы, или "вилки" как я их называю. 
Если код должен выполняться один раз, то это тот же цикл, только за один проход. 
Оператор "If" это частный случай для "switch". А "switch" это по сути безусловный переход.
Остальное, это вызов подфункций (иерархия) и обмен даннымы между объектами.

 Смысл движка состоит в том что бы набором универсальных блоков можно было бы легко
составлять любой код, любой сложности. Элементы можно просто менять и убирать, достаточно
просто закоментировать ненужное. Так же очень просто можно копировать код из одного объекта в 
другой, меняя просто параметры. Этот принцип применим к любой программе,
 так как он инвариантен(независим) относительно информации. Существует аксиома: количество
 ошибок в коде прямопропорционально количеству кода......   единственный способ избежать 
 потенциальных багов это писать меньше, но качественнее.

Структура программы делится на две части, оболочка и объекты. Всё действие происходит внутри
объектов, они лежат в специальной группе "objects", и каждый из них устроен по одинаковому принципу.
Остальная часть это внешняя оболочка, которая обеспечивает работоспособность. 
//======================================================================================================
Внешняя оболочка:

UniCell  - универсальная ячейка. Это контейнер, который может содержать в себе данные любого типа.
(vector, color, float, int , bool, point, Id, NString) При необходимости можно расширить. Нужен для
универсального обмена данными между объектами.

ConstantsAndMacros - Определения всех макросов, которые используются в движке, для уменьшения кода.

Processor_ex - Процессор для объектов. Обеспечивает все процессы в движке. К нему я ещё вернусь.

Mega_tree - это огромное хранилище данных, всевозможных типов. Это аналог глобальных переменных, но
при этом они являются динамическими, мы можем их создать и удалять. Хранятся данные в виде ячеек (UniCell)
Дерево нужно для универсального обмена информацией между объектами. Доступно в любом объекте из любого
места для чтения и записи. Доступ к переменным осуществляется по имени через макросы: 

GET_INT_V(...)
GET_FLOAT_V(...)
GET_BOOL_V(...)
GET_VECTOR_V(...)
GET_COLOR_V(...)
GET_ID_V(...)
GET_POINT_V(…)

каждый макрос возвращает указатель на данный тип переменной. Вместо многоточия должно стоять имя
переменной(строка). Так же можно перечислить имена через запятую, в случае если имя составное.
Все названия будут собраны в одно слева направо. Например:

int *ScoreAdd=GET_INT_V(@"Score",@"iScoreAdd");
Мы получаем указатель на переменную типа int в которой хранятся очки игры. Реальное имя складывается 
из двух частей и используется как хеш в дереве для получения данных. 
В данном случае оно равно @"ScoreiScoreAdd". Если частей может быть больше, например 3 или 6.
Это зависит от конкретной задачи. Например в процессах внутренние переменные так же хранятся в 
Mega_tree и имена их складываются из 4 частей @"Имя объекта" @"Имя Процесса" @"Имя Стадии" @"Имя Переменной".
Такая схема именования выбрана для того что получить уникальность имени.

Для того что бы положить что либо в дерево на хранение вызываем следующую функцию, она доступна из
любого места в объекте. Пример:

[m_pObjMng->pMegaTree SetCell:SET_STRING_V(@"Test",@"Name",@"Str_TCorp")];

В данном случае мы создаём внутри дерева переменную типа NSMutableString с составным именем
@"Name"+@"Str_TCorp" и присваиваем значение @"Test".

можно написать следующее:
[m_pObjMng->pMegaTree SetCell:LINK_STRING_V(m_strName,@"Name",@"Str_TCorp")];
разница в том что в данном случаем мы лункуем переменную, а не создаём отдельно в памяти как в предыдущем
случае. В даммом случае переменная хранится например где нибудь в объекте.
С помощью такой схему можно создавать связи любой сложности между объектами, и обмен будет так же прост.
Нужно просто знать имя и всё. Можно например создать внутри дерева глобальную переменную и связать её
с указателями в классах, и просто через эти указатели менять или получать значение без лишнего кода.

Dictionary_Ex - это расширенный класс NSMutableDictionary, особенность его заключается только в том 
что в нём реализована функция SynhData. Нужна она для синхронизации данных. Вообще весь смысл этого класса
в том что бы сделать так что бы можно было модифицировать сам словарь даже если мы перебираем его элементы
внутри какого-нибудь процесса. Поэтому я синхронизацию вынес за главный цикл обработки приложения.

ObjectManager_Ex - менеджер для управления объектами. Он их умеет создавать, обрабатывать и уничтожать.

MainController
PreviewController
RootViewController - контроллеры приложения, RootViewController является родителем для двух других. Это 
сделано что бы можно было видеть анимацию перелистывания контроллеров.

PrSettings - Класс для работы с сохраняемыми данными. К нему так же относятся файлы DtManager и PlManager

OpenGLCommon - макросы OpenGL
GLView - реализация OpenGL контекста.

EngineAppDelegate - главный делегат
//======================================================================================================
Объекты:
Теперь вторая часть движка, Которая состоит из самих объектов. все объекты лежат в группе objects.
Обработка объектов происходит в 2 этапа, сначала обработка действия, затем отрисовка. Объекты 
могут быть разными, одни рисуются в виде спрайтов, другие не видемые, например триггер или другие
управляющие объекты, которые управляют например кучкой спрайтиков, или определяю какой следующий уровень игры.
Такие объекты должны быть невидимы, для них надо выставить флаг m_bHiden=YES; тогда этот объект не будет 
рисоваться.

Все объекты наследуються от класса GObject, который находится в файле Object.h. Можно наследовать и от других
объектов, главное что бы GObject был в самом начале наследования. GObject это основной главный объект. Все 
первоначальные объекты в сцене загружаются в объекте CGameLogic который определён в файле GameLogicObject.
Например что бы начать новый проект, нужно просто удалить объекты из этой загрузки, а так же из проекта,
но некоторые могут понадобиться. Такая система позволяет повторно использовать объекты в самых разных
случаях и проектах. Там же где необходимо можно легко поменять объект, для этого мы его копируем,
переименовываем и вносим изменения в код. Если вам необходим новый объект с нуля, то для этой цели есть
ObjectTemplet в файле ObjectTemplet.h. Что бы создать новый объект копируем темплет. Затем нужно 
переименовать название класса, и имена файлов, и можно делать объект. Загружаются объекты специальным
макросом. Его можно вызывать везде, внутри объектов, без ограничения.

CREATE_NEW_OBJECT(@"ObjectTest",@"Test",nil);

@"ObjectTest" - это имя созданного вами класса.
@"Test" - имя объекта. Имя уникально всегда. следить за этим не обязательно, потому что если например
эту строчку написать два раза то буду созданы два объекта @"Test" и @"Test1". При создании объекта 
уникальность имени проверяется, если такое имя уже есть, то к нему добавляется число и снова проверяется
на уникальность, и так пока не будет найдено уникальное имя. Имена это самая главная часть объекта, так
как на имени затем генерируются имена-хеши переменных. Так же имена много где используются.
nil - это параметры объекта. Это массив типа NSArray. В котором содержатся UniCell различных параметров.
у каждого параметра есть своё уникальное имя. Для каждого объекта есть набор стандартных параметров, их 
можно посмотреть классе GObject в функции LinkValues. Например:

    CREATE_NEW_OBJECT(@"ObjectScore",@"Score",
		      SET_COLOR_V(Color3DMake(1, 1, 1, 1),@"mColor"),
		      SET_VECTOR_V(Vector3DMake(450,275,0.0f),@"m_pCurPosition"),
              SET_STRING_V(@"ScaleWave", @"m_strStartStage"),
              SET_STRING_V(@"_0.png", @"m_pNameTexture"),
              SET_FLOAT_V(24,@"m_fWNumber"),
              SET_INT_V(-1, @"m_iAlign"),
              SET_BOOL_V(YES, @"m_bNoOffset"),
              SET_INT_V(layerInterfaceSpace6,@"m_iLayer"));

Этот макрос создаёт объект @"ObjectScore" с именем @"Score" . И различными параметрами.
порядок параметров не важен. Количество определяется только вами. Что то можно выкинуть
или наоборот добавить. Даже если если будет написана ошибка, то переменная просто не будет найдена.

SET_COLOR_V(Color3DMake(1, 1, 1, 1),@"mColor") 			Color - цвет символов
SET_VECTOR_V(Vector3DMake(450,275,0.0f),@"m_pCurPosition"),	Vector - Позиция
SET_STRING_V(@"ScaleWave", @"m_strStartStage"),			String - Начальная стадия процесса
SET_STRING_V(@"_0.png", @"m_pNameTexture"),			String - Имя текстуры для символов
SET_FLOAT_V(24,@"m_fWNumber"),					float - Ширина символов
SET_INT_V(-1, @"m_iAlign"),					int - выравнивание символов
SET_BOOL_V(YES, @"m_bNoOffset"),				bool - Флаг смещения
SET_INT_V(layerInterfaceSpace6,@"m_iLayer")			int - слой для отрисовки.

Для того, что бы установить для объекта параметры есть специальный макрос. На вызов его так же нет
ограничений внутри объектов. Например:

OBJECT_SET_PARAMS(@"NameObject",
               SET_INT_V(0,@"m_iCurrentSym"),
               SET_VECTOR_V(Vector3DMake(0,0,0),@"m_pOffsetCurPosition"),
               SET_BOOL_V(NO,@"m_bHiden"));

он почти такой же как и макрос для создания объектов, Здесь нет только имени класса. Необходимо
знать имя объекта. В данном случае имя @"NameObject"

Для удаления объекта со сцены используется макрос:

DESTROY_OBJECT(OB)

OB - id объекта. Тоесть сам идентификатор класса.

эту функцию можно вызывать везде и для любого объекта. С помощью неё объект может удалить и сам себя:
DESTROY_OBJECT(self);

При этом объект помещается во временной стек и у него обнуляется имя. При повторном создании менеджер
ищет объект этого класса сначала в стеке, если стек пуст, создаётся новый экземпляр.

А теперь рассмотрим сам класс темплет. Внутри класса есть все необходимые заготовки для создания 
объекта. 

Главная функция инициализации, вызывается один раз при создании объекта.
- (id)Init:(id)Parent WithName:(NSString *)strName{
	self = [super Init:Parent WithName:strName];
	if (self != nil)
    {
        m_iLayer = layerTemplet;
        m_iLayerTouch=layerTouch_0;//слой касания
    }
    
	return self;
}

m_iLayer - слой отрисовки объекта, разные слои определены в CObjectManager, слои можно добавить если нехватает,
просто надо расширить EGP_LayerID. Этим мы получим эффект того, что одни объекты отображаются поверх других.

m_iLayerTouch - слой касания. Для того что бы объект был интерактивным (тоесть его можно было бы коснуться). 
нужно поспользоваться функцией:
- (void)SetTouch:(bool)bTouch;
этой же функцией можно отключить взаимодействие.
Взаимодейсвие определяется шестью функциями. Которые вызываются внутри объекта из контроллера. Одна из таких
 есть в темплете.
- (void)touchesBegan:(UITouch *)CurrentTouch WithPoint:(CGPoint)Point; - прикосновение началось
- (void)touchesMoved:(UITouch *)CurrentTouch WithPoint:(CGPoint)Point; - движение прикосновения
- (void)touchesEnded:(UITouch *)CurrentTouch WithPoint:(CGPoint)Point; - прикосновение закончилось
- (void)touchesMovedOut:(UITouch *)CurrentTouch WithPoint:(CGPoint)pPoint; - движение вне объекта
- (void)touchesBeganOut:(UITouch *)CurrentTouch WithPoint:(CGPoint)Point; - прикосновение началось вне объекта
- (void)touchesEndedOut:(UITouch *)CurrentTouch WithPoint:(CGPoint)Point; - прикосновение закончилось вне
объекта

- (void)SetDefault; - метод который вызывается всегда при создании объекта, для установления параметров
по умолчанию
- (void)LinkValues; - метод который вызывается, после - (void)SetDefault; ответственен за линкование
нужных переменных
и определения процессоров (о них в конце)

- (void)Start; - метод, который вызывается когда объект начинает действовать, после того как все
параметры слинкованы.
Обычно я использую его для генерации других объектов и установки некоторых параметров.

mTextureId = [m_pParent GetTextureId:m_pNameTexture]; - Эта строчка присваивает текстуру данному объекту
по имени. Что бы текстура загрузилась её нужно просто положить в папку texture. Все текстуры грузятся автоматически.
 Тоже самое и со звуками. Они используются по аналогии. Главное знать имя текстуры или звука.
PLAY_SOUND(@""); - макрос для воспроизведения звука по имени.
STOP_SOUND(@""); - макрос для остановки звука (нужен для звуков, которые зациклены)

GET_DIM_FROM_TEXTURE(@""); - макрос уснановки ширины и высоты спрайта как у текстуры.

- (void)Destroy; - метод который вызывается когда объект удаляется со сцены макросом DESTROY_OBJECT(OB);
полезен для некоторых действий.

[m_pObjMng AddToGroup:@"NameGroup" Object:self]; - группировка объекта. группы нужны для того что бы легко
 можно было перечислять какие нибудь объекты и делать с ними какие нибудь действия. Например есть десять частиц.
 что бы не создавать управляющий объект мы можем просто сгруппировать частицы. Далее из другого 
объекта можно вызвать метод GetGroup и получить все эти частицы одним массивом и делать с ним другие действия.
//======================================================================================================
Процессы:

последняя часть касается процессов. Посмотрим на запись:

 Processor_ex* pProc = [self START_QUEUE:@"Proc"];
    ASSIGN_STAGE(@"IDLE",@"Idle:",nil);
	ASSIGN_STAGE(@"PROC",@"Proc:",nil);
 [self END_QUEUE:pProc name:@"Proc"];

данная запись определят процесс для данного объекта с именем @"Proc", в котором есть две стадии. Процессы
 должны быть определены внутри метода LinkValues. Процессов может быть много, главное названия что бы были
разные, в пределах объекта. Макрос ASSIGN_STAGE(@"IDLE",@"Idle:",nil); определяет стадию внутри просесса, с
именем @"IDLE" и именем селектора @"Idle:". Параметры в стадиях отсутвуют. Второй макрос определяет вторую стадию
 с именем @"PROC" и селектором @"Proc:". Стадий может быть сколько угодно, порядок написания определяет
порядок следования друг за другом. Для того, что бы перейти на следующую стадию нужно вызвать:
NEXT_STAGE внутри селектора процессора. Если данная стадия последняя то процессор переходит на
начало. Имена селекторов должны совпадать с именами. когда мы определяем стадию необходимо так же прописать
в объекте селектор. В данном случае это @"Proc:". Можно видеть что в объекте темплета есть этот метод. Точно так же можно определить сколь угодно селекторов с разными именами. Во время определения стадий
вызывается метод инициализации для данной стадии, он не обязателен, но бывает очень полезен. Имя
этого вызова складывается из @"Init" и имени селектора. Например для @"Proc: это будет @"InitProc:".
Он так же присутствует в темплете, а так же метод PrepareProc. Этот метод вызывается всегда когда данная
стадия была установленна в действие и вызывается один раз. По умолчанию процессор выставляет первую стадию.



